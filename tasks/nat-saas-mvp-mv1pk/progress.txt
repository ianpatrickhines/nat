# Ralph Progress Log - nat-saas-mvp
Started: 2025-01-12
---

## 2025-01-12 - US-001: CloudFormation base infrastructure

**Implementation:**
- Created `infrastructure/template.yaml` with CloudFormation resources
- Tenants table: tenant_id PK, stripe_customer_id GSI, PAY_PER_REQUEST, PITR enabled
- Users table: user_id PK, tenant_id GSI, email GSI, PAY_PER_REQUEST, PITR enabled
- Lambda execution role with policies for DynamoDB (CRUD on both tables + indexes) and Secrets Manager (nat/* secrets)
- All stateful resources have DeletionPolicy: Retain
- Added `pyproject.toml` with mypy and cfn-lint configuration

**Learnings:**
- Project has pre-existing Python code in src/nat/ with type issues - future stories should not break existing mypy
- cfn-lint is the preferred way to validate CloudFormation in this project
- Template exports table names/ARNs and role ARN for cross-stack references

## 2025-01-12 - US-002: API Gateway REST API setup

**Implementation:**
- Added API Gateway REST API (`nat-api-${Environment}`) to `infrastructure/template.yaml`
- Created `/health` endpoint with MOCK integration returning `{"status": "healthy"}` and 200 OK
- Configured CORS headers on health endpoint (GET + OPTIONS preflight)
- Added GatewayResponse resources for CORS headers on 4XX and 5XX error responses
- CORS allows all origins (`*`) with standard headers + custom `X-Nat-User-Id`, `X-Nat-Tenant-Id`
- Added deployment and stage resources for environment-specific URLs
- Exported API Gateway ID, Root Resource ID, API URL, and Health Check URL

**Learnings:**
- API Gateway MOCK integrations can't use CloudFormation `${Variable}` substitution in response templates - they're runtime templates
- GatewayResponse resources are required for CORS headers on error responses (4XX/5XX)
- Custom domain parameter left commented out as placeholder - will need ACM certificate and Route 53 for full implementation
- OPTIONS preflight methods required for each resource that will receive cross-origin requests

## 2025-01-12 - US-003: Stripe webhook Lambda

**Implementation:**
- Created `src/lambdas/stripe_webhook/handler.py` with full Lambda handler
- Webhook signature verification using HMAC-SHA256 with timestamp tolerance (5 min)
- `checkout.session.completed`: Creates tenant record with plan, query limits, billing cycle; creates initial admin user
- `customer.subscription.updated`: Updates subscription status, plan, query limits; resets usage count on new billing cycle
- `customer.subscription.deleted`: Marks subscription as cancelled
- CloudFormation: Lambda function, Lambda permission, `/stripe/webhook` API Gateway resource with POST + OPTIONS
- Webhook secret retrieved from Secrets Manager (`nat/stripe-webhook-secret-${Environment}`)
- 22 unit tests covering all event handlers, signature verification, edge cases

**Learnings:**
- Stripe signature header can be `Stripe-Signature` or `stripe-signature` depending on API Gateway configuration - handle both
- DynamoDB GSI queries return list even for single matches - always check `Items` array
- Plan name can be inferred from Stripe price_id if explicit mapping not configured
- mypy strict mode requires explicit type annotations for all variables even when obviously string (e.g., `secret: str = response.get("SecretString", "")`)
- Lambda ZipFile in CloudFormation is placeholder only - actual code deployed separately via CI/CD

## 2025-01-12 - US-004: Subscription verification middleware

**Implementation:**
- Created `src/lambdas/shared/subscription_middleware.py` as reusable middleware
- Extracts user identity from `X-Nat-User-Id` and `X-Nat-Tenant-Id` headers (case-insensitive)
- Looks up user in Users table to get tenant_id if not provided in headers
- Checks tenant subscription status - allows `active` and `trialing` statuses
- Returns 401 Unauthorized if user header missing or user not found
- Returns 402 Payment Required if subscription is inactive (cancelled/past_due/unpaid)
- Returns 403 Forbidden if query limit exceeded (queries_this_month >= queries_limit)
- Supports decorator pattern via `@SubscriptionMiddleware()` for Lambda handlers
- Added `src/__init__.py` and `src/lambdas/__init__.py` for proper module structure
- 26 unit tests covering all error cases and success paths

**Learnings:**
- mypy `--explicit-package-bases` flag needed to avoid "module found twice" errors with nested packages
- API Gateway may lowercase headers - normalize to lowercase for comparison
- TypedDict is useful for documenting Lambda response structure while maintaining dict compatibility
- Decorator pattern allows clean integration with existing Lambda handlers while providing error handling

## 2025-01-12 - US-005: NationBuilder OAuth callback Lambda

**Implementation:**
- Created `src/lambdas/nb_oauth_callback/handler.py` with full OAuth callback handler
- Receives OAuth callback with authorization code and base64-encoded state parameter
- State contains: user_id, nb_slug, redirect_uri for reconstructing the flow
- Exchanges authorization code for access_token and refresh_token via NB token endpoint
- Stores tokens in Secrets Manager at `nat/user/{user_id}/nb-tokens` with metadata (expires_at, nb_slug)
- Updates user record: nb_connected=true, nb_slug, nb_token_expires_at, nb_needs_reauth=false
- Returns 302 redirect to success page on success, error page with error query param on failure
- CloudFormation: Lambda function + `/auth/nationbuilder/callback` GET endpoint with CORS
- 15 unit tests covering success flow, error handling, edge cases

**Learnings:**
- NB OAuth tokens endpoint expects form-encoded POST body, not JSON
- State parameter is base64-encoded JSON to pass user context through OAuth redirect flow
- Token exchange uses urllib3 directly since boto3 doesn't have HTTP client
- Secrets Manager `put_secret_value` raises `ResourceNotFoundException` if secret doesn't exist - need fallback to `create_secret`
- OAuth callback returns redirect (302) not JSON - browser handles redirect automatically

## 2025-01-12 - US-006: Token refresh Lambda with EventBridge

**Implementation:**
- Created `src/lambdas/token_refresh/handler.py` with full token refresh logic
- Scans Users table for tokens expiring in next 12 hours (configurable via TOKEN_EXPIRY_WINDOW_HOURS)
- Filter: nb_connected=true AND nb_needs_reauth!=true AND nb_token_expires_at <= window_end
- Refreshes tokens via NB OAuth token endpoint with grant_type=refresh_token
- Stores new tokens in Secrets Manager (NB refresh tokens are single-use, so new refresh_token must be saved)
- Updates user record with new nb_token_expires_at on success
- Sets nb_needs_reauth=true on failure (user will see "Reconnect" in extension)
- CloudFormation: Lambda function (5 min timeout) + EventBridge rule with rate(12 hours) schedule
- Handler returns summary: processed count, succeeded count, failed count, failure details
- 18 unit tests covering all paths: success, no tokens, no refresh_token, API failure, batch processing

**Learnings:**
- NB refresh tokens are single-use - new refresh_token in response must be stored to replace old one
- DynamoDB scan FilterExpression uses Attr() for attribute conditions (from boto3.dynamodb.conditions)
- EventBridge rule uses AWS::Events::Rule with ScheduleExpression: 'rate(12 hours)'
- Lambda permission for EventBridge uses Principal: events.amazonaws.com with SourceArn pointing to rule
- Pagination handling needed for DynamoDB scan (LastEvaluatedKey/ExclusiveStartKey)
- Lambda timeout increased to 300s to handle many users in single invocation

## 2025-01-12 - US-007: Port Nat agent to Lambda

**Implementation:**
- Created `src/lambdas/nat_agent/handler.py` Lambda handler for AI agent queries
- Handler receives query and optional page context (page_type, person_name, person_id, list_name, event_name)
- Extracts user_id from request body or X-Nat-User-Id header
- Verifies user exists, has nb_connected=true, and nb_needs_reauth=false before processing
- Retrieves NB tokens from Secrets Manager at `nat/user/{user_id}/nb-tokens`
- Uses existing `create_nat_options()` from src/nat/agent.py to configure Claude SDK with all 66 tools
- Returns JSON response with `response` (text) and `tool_calls` (list of tool invocations)
- Error handling returns appropriate HTTP codes: 400 (bad request), 403 (NB not connected), 404 (user not found), 500 (agent error)
- CloudFormation: Lambda function (120s timeout, 512MB memory) + POST /agent/query endpoint with CORS
- 23 unit tests covering API key retrieval, token retrieval, user info, and handler flows

**Learnings:**
- Lambda imports should be done inside handler functions to avoid cold start issues with large packages like claude_agent_sdk
- mypy requires explicit type annotations for DynamoDB response.get("Item") to avoid "Returning Any" errors
- asyncio.get_event_loop().run_until_complete() bridges sync Lambda handler with async Claude SDK
- Page context allows agent to be aware of what user is viewing (person profile, list, event) for context-aware responses
- Error codes (NB_NOT_CONNECTED, NB_NEEDS_REAUTH, NB_TOKENS_MISSING, AGENT_ERROR) help extension show appropriate UI

## 2025-01-12 - US-008: SSE streaming response handler

**Implementation:**
- Created `src/lambdas/nat_agent_streaming/handler.py` for SSE streaming responses
- Uses Lambda Function URL with RESPONSE_STREAM invoke mode for true streaming (API Gateway doesn't support SSE streaming)
- SSE event types: `text` (partial response chunks), `tool_use` (tool invocations), `tool_result` (results), `error`, `done`
- `done` event includes complete response text and array of all tool_calls for client state management
- CloudFormation adds NatAgentStreamingFunction (120s timeout, 512MB) + NatAgentStreamingUrl with CORS
- Lambda URL configured with AuthType: NONE and CORS for Chrome extension access
- Standard handler() for non-streaming invocation (testing), streaming_handler() for actual streaming
- 25 unit tests covering SSE formatting, request validation, error cases, and handler flows

**Learnings:**
- Lambda Function URLs with RESPONSE_STREAM invoke mode are required for true SSE streaming - API Gateway doesn't support it
- AWS::Lambda::Url resource with InvokeMode: RESPONSE_STREAM enables response streaming
- Lambda URL permission requires `lambda:InvokeFunctionUrl` action, not `lambda:InvokeFunction`
- FunctionUrlAuthType in permission must match AuthType in URL config
- SSE format: `event: {type}\ndata: {json}\n\n` - double newline terminates event
- Async generator pattern works well for streaming: `async for event in process_streaming_request(body):`
- pytest async tests without pytest-asyncio can use run_async() helper with asyncio.get_event_loop().run_until_complete()

## 2025-01-12 - US-009: Usage tracking and rate limiting

**Implementation:**
- Created `src/lambdas/shared/usage_tracking.py` with core functions:
  - `check_rate_limit()`: Enforces 5-second cooldown per user, raises RateLimitError with retry_after
  - `update_last_query_time()`: Updates user's last_query_at timestamp
  - `increment_query_count()`: Atomic increment of tenant's queries_this_month using DynamoDB conditional update
  - `check_and_reset_billing_cycle()`: Checks if billing cycle has started and resets usage counter
  - `track_query_usage()`: Convenience function that updates time and increments count
- Added RATE_LIMIT_EXCEEDED to SubscriptionErrorCode enum in subscription middleware
- Integrated into nat_agent handler: rate check before query, usage tracking after success
- Integrated into nat_agent_streaming handler: rate check before streaming, usage tracking after done event
- Added TENANTS_TABLE environment variable to NatAgentFunction and NatAgentStreamingFunction in CloudFormation
- 20 unit tests covering all functions, edge cases, and Decimal handling

**Learnings:**
- DynamoDB returns Decimal types for numbers - need to convert to int for comparisons
- Atomic increment uses `SET queries_this_month = if_not_exists(queries_this_month, :zero) + :inc`
- Rate limiting "fails open" on errors - don't block users due to DynamoDB issues
- Usage tracking happens AFTER successful query to avoid charging for failed requests
- For streaming, need to detect success by checking done event without error
- Retry-After header in 429 response helps clients implement proper backoff
## 2025-01-12 - US-010: Chrome extension scaffold

**Implementation:**
- Created `extension/` directory with complete Manifest V3 Chrome extension scaffold
- `public/manifest.json` - Manifest V3 with storage/activeTab permissions, host_permissions for *.nationbuilder.com
- `vite.config.ts` - Builds content.js and background.js, copies manifest.json and content.css to dist
- `tsconfig.json` - TypeScript strict mode with Preact JSX config and @types/chrome
- `src/content/index.tsx` - Entry point that injects sidebar container on NB pages
- `src/components/Sidebar.tsx` - Preact component with open/collapsed states (350px/40px)
- `src/content/content.css` - Scoped CSS with maximum z-index and style reset to avoid NB conflicts
- `src/background/index.ts` - Service worker with auth state management and message passing
- Build produces: content.js (13.99kb), background.js (0.80kb), content.css, manifest.json

**Learnings:**
- Manifest V3 uses service workers instead of background pages - no persistent state
- chrome.storage.local is the correct place for auth tokens in MV3 (not localStorage)
- Content scripts need CSS isolation - using `all: initial` and high z-index prevents NB style conflicts
- Vite custom plugin for closeBundle hook copies non-bundled files (manifest.json, css) to dist
- @types/chrome provides TypeScript definitions for chrome.* APIs
- Preact with `jsxImportSource: "preact"` in tsconfig works seamlessly as React replacement
- Extension can load without icons - Chrome uses default placeholder icon

## 2025-01-12 - US-011: Background service worker

**Implementation:**
- Enhanced `extension/src/background/index.ts` with full service worker functionality
- Auth state management: AuthState type with isAuthenticated, userId, tenantId, nbConnected, nbNeedsReauth, subscriptionStatus
- Storage functions: getAuthState(), setAuthState(), clearAuthState(), setNbConnection(), setSubscriptionStatus()
- Message handling: GET/SET/CLEAR_AUTH_STATE, SET_NB_CONNECTION, SET_SUBSCRIPTION_STATUS, SUBMIT_QUERY, CANCEL_QUERY, GET_STREAMING_STATE
- SSE connection: parseSSEEvent() and processSSEStream() for Lambda Function URL streaming
- Response broadcasting: broadcastToNbTabs() to all *.nationbuilder.com tabs
- Keepalive: chrome.alarms to prevent MV3 service worker termination during streaming
- Added `alarms` permission to manifest.json

**Learnings:**
- Manifest V3 service workers are ephemeral - they can be killed at any time. Use chrome.alarms as a keepalive mechanism during long-running operations like SSE streaming
- chrome.tabs.query() with url pattern returns all matching tabs; use try/catch when sending messages as content script may not be loaded
- SSE events are separated by double newlines (`\n\n`) - need to buffer and split properly
- chrome.storage.onChanged listener allows syncing auth state changes across tabs automatically
- Service workers don't have persistent state - use chrome.storage.local for anything that needs to survive restarts
- AbortController works in service workers for cancelling fetch requests
- ReadableStreamDefaultReader with TextDecoder handles chunked SSE responses properly

